--- Rtrtri.cpp~	2021-04-06 06:58:24.424353540 +0900
+++ Rtrtri.cpp	2021-04-06 07:00:50.544453772 +0900
@@ -93,7 +93,10 @@
     //
     //     Determine the block size for this environment.
     //
-    INTEGER nb = iMlaenv(1, "Rtrtri", uplo + diag, n, -1, -1, -1);
+    char buf[100];
+    strcpy(buf, uplo);
+    strcat(buf, diag);
+    INTEGER nb = iMlaenv(1, "Rtrtri", buf, n, -1, -1, -1);
     INTEGER j = 0;
     INTEGER jb = 0;
     const REAL one = 1.0;
--- Rlansy.cpp~	2021-04-06 08:33:13.273502490 +0900
+++ Rlansy.cpp	2021-04-06 08:37:37.437468841 +0900
@@ -63,9 +63,9 @@
     INTEGER i = 0;
     REAL sum = 0.0;
     REAL absa = 0.0;
-    arr_1d<2, REAL> ssq(fill0);
+    REAL ssq[2];
     const REAL one = 1.0;
-    arr_1d<2, REAL> colssq(fill0);
+    REAL colssq[2];
     if (n == 0) {
         value = zero;
     } else if (Mlsame(norm, "M")) {
--- Rgetri.cpp~	2021-04-06 08:41:16.668398293 +0900
+++ Rgetri.cpp	2021-04-06 08:42:49.250699928 +0900
@@ -93,10 +93,10 @@
     INTEGER ldwork = n;
     INTEGER iws = 0;
     if (nb > 1 && nb < n) {
-        iws = max(ldwork * nb, 1);
+        iws = max(ldwork * nb, (INTEGER)1);
         if (lwork < iws) {
             nb = lwork / ldwork;
-            nbmin = max(2, iMlaenv(2, "Rgetri", " ", n, -1, -1, -1));
+            nbmin = max((INTEGER)2, iMlaenv(2, "Rgetri", " ", n, -1, -1, -1));
         }
     } else {
         iws = n;
--- Rlaorhr_col_getrfnp2.cpp~	2021-04-06 09:15:54.292429657 +0900
+++ Rlaorhr_col_getrfnp2.cpp	2021-04-06 09:17:11.624988625 +0900
@@ -88,7 +88,7 @@
         //
         //        Transfer the sign
         //
-        d[1 - 1] = -sign(one, &a[(1 - 1)]);
+        d[1 - 1] = -sign(one, a[(1 - 1)]);
         //
         //        Construct the row of U
         //
@@ -101,7 +101,7 @@
         //
         //        Transfer the sign
         //
-        d[1 - 1] = -sign(one, &a[(1 - 1)]);
+        d[1 - 1] = -sign(one, a[(1 - 1)]);
         //
         //        Construct the row of U
         //
--- Rlapy3.cpp~	2021-04-06 09:15:54.608429638 +0900
+++ Rlapy3.cpp	2021-04-06 09:17:49.140414965 +0900
@@ -52,7 +52,7 @@
     REAL xabs = abs(x);
     REAL yabs = abs(y);
     REAL zabs = abs(z);
-    REAL w = max(xabs, yabs, zabs);
+    REAL w = max(max(xabs, yabs), zabs);
     const REAL zero = 0.0;
     if (w == zero) {
         //     W can be zero for max(0,nan,0)
--- Rlarfb.cpp~	2021-04-06 09:41:30.176341327 +0900
+++ Rlarfb.cpp	2021-04-06 09:45:58.191156448 +0900
@@ -58,11 +58,11 @@
         return;
     }
     //
-    str<1> transt = char0;
+    char transt;
     if (Mlsame(trans, "N")) {
-        transt = "T";
+        transt = 'T';
     } else {
-        transt = "N";
+        transt = 'N';
     }
     //
     INTEGER j = 0;
@@ -101,7 +101,7 @@
                 //
                 //              W := W * T**T  or  W * T
                 //
-                Rtrmm("Right", "Upper", transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
+                Rtrmm("Right", "Upper", &transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
                 //
                 //              C := C - V * W**T
                 //
@@ -203,7 +203,7 @@
                 //
                 //              W := W * T**T  or  W * T
                 //
-                Rtrmm("Right", "Lower", transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
+                Rtrmm("Right", "Lower", &transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
                 //
                 //              C := C - V * W**T
                 //
@@ -307,7 +307,7 @@
                 //
                 //              W := W * T**T  or  W * T
                 //
-                Rtrmm("Right", "Upper", transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
+                Rtrmm("Right", "Upper", &transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
                 //
                 //              C := C - V**T * W**T
                 //
@@ -409,7 +409,7 @@
                 //
                 //              W := W * T**T  or  W * T
                 //
-                Rtrmm("Right", "Lower", transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
+                Rtrmm("Right", "Lower", &transt, "Non-unit", n, k, one, t, ldt, work, ldwork);
                 //
                 //              C := C - V**T * W**T
                 //
--- Rorgqr.cpp_org	2021-04-06 10:24:08.675295850 +0900
+++ Rorgqr.cpp	2021-04-06 10:32:41.350138705 +0900
@@ -94,7 +94,7 @@
         //
         //        Determine when to cross over from blocked to unblocked code.
         //
-        nx = max(0, iMlaenv(3, "Rorgqr", " ", m, n, k, -1));
+        nx = max((INTEGER)0, iMlaenv(3, "Rorgqr", " ", m, n, k, -1));
         if (nx < k) {
             //
             //           Determine if workspace is large enough for blocked code.
@@ -107,7 +107,7 @@
                 //              determine the minimum value of NB.
                 //
                 nb = lwork / ldwork;
-                nbmin = max(2, iMlaenv(2, "Rorgqr", " ", m, n, k, -1));
+                nbmin = max((INTEGER)2, iMlaenv(2, "Rorgqr", " ", m, n, k, -1));
             }
         }
     }

Rlartgs calls Rlartgp which might changes const cs and cosnt sn
--- Rlartgs.cpp~	2021-04-06 10:24:05.420296044 +0900
+++ Rlartgs.cpp	2021-04-06 10:37:18.068372309 +0900
@@ -29,7 +29,7 @@
 #include <mpblas.h>
 #include <mplapack.h>
 
-void Rlartgs(REAL const x, REAL const y, REAL const sigma, REAL const cs, REAL const sn) {
+void Rlartgs(REAL const x, REAL const y, REAL const sigma, REAL cs, REAL sn) {
     //
     //  -- LAPACK computational routine --
     //  -- LAPACK is a software package provided by Univ. of Tennessee,    --
--- Rlascl.cpp~	2021-04-06 10:24:05.763296023 +0900
+++ Rlascl.cpp	2021-04-06 10:38:51.031215922 +0900
@@ -106,9 +106,9 @@
     } else if (itype <= 3 && lda < max((INTEGER)1, m)) {
         info = -9;
     } else if (itype >= 4) {
-        if (kl < 0 || kl > max(m - 1, 0)) {
+        if (kl < 0 || kl > max(m - 1, (INTEGER)0)) {
             info = -2;
-        } else if (ku < 0 || ku > max(n - 1, 0) || ((itype == 4 || itype == 5) && kl != ku)) {
+        } else if (ku < 0 || ku > max(n - 1, (INTEGER)0) || ((itype == 4 || itype == 5) && kl != ku)) {
             info = -3;
         } else if ((itype == 4 && lda < kl + 1) || (itype == 5 && lda < ku + 1) || (itype == 6 && lda < 2 * kl + ku + 1)) {
             info = -9;
@@ -223,7 +223,7 @@
         k1 = ku + 2;
         k3 = ku + 1;
         for (j = 1; j <= n; j = j + 1) {
-            for (i = max(k1 - j, 1); i <= k3; i = i + 1) {
+            for (i = max(k1 - j, (INTEGER)1); i <= k3; i = i + 1) {
                 a[(i - 1) + (j - 1) * lda] = a[(i - 1) + (j - 1) * lda] * mul;
             }
         }
--- Rlasrt.cpp	2021-04-06 10:47:58.800614463 +0900
+++ Rlasrt.cpp	2021-04-06 10:49:17.940637323 +0900
@@ -32,7 +32,8 @@
 void Rlasrt(const char *id, INTEGER const n, REAL *d, INTEGER &info) {
     INTEGER dir = 0;
     INTEGER stkpnt = 0;
-    arr_2d<2, 32, INTEGER> stack(fill0);
+    INTEGER stacklen = 32;
+    INTEGER stack[2 * stacklen];
     INTEGER start = 0;
     INTEGER endd = 0;
     const INTEGER select = 20;
@@ -93,11 +94,11 @@
     }
     //
     stkpnt = 1;
-    stack(1, 1) = 1;
-    stack(2, 1) = n;
+    stack[(1 - 1) + (1 - 1) * stacklen] = 1;
+    stack[(2 - 1) + (1 - 1) * stacklen] = n;
 statement_10:
-    start = stack(1, stkpnt);
-    endd = stack(2, stkpnt);
+    start = stack[(1 - 1) + (stkpnt - 1) * stacklen];
+    endd = stack[(2 - 1) + (stkpnt - 1) * stacklen];
     stkpnt = stkpnt - 1;
     if (endd - start <= select && endd - start > 0) {
         //
@@ -192,22 +193,22 @@
             }
             if (j - start > endd - j - 1) {
                 stkpnt++;
-                stack(1, stkpnt) = start;
-                stack(2, stkpnt) = j;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = start;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = j;
                 stkpnt++;
-                stack(1, stkpnt) = j + 1;
-                stack(2, stkpnt) = endd;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = j + 1;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = endd;
             } else {
                 stkpnt++;
-                stack(1, stkpnt) = j + 1;
-                stack(2, stkpnt) = endd;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = j + 1;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = endd;
                 stkpnt++;
-                stack(1, stkpnt) = start;
-                stack(2, stkpnt) = j;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = start;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = j;
             }
         } else {
             //
-            //           Sort INTEGERo increasing order
+            //           Sort into increasing order
             //
             i = start - 1;
             j = endd + 1;
@@ -230,18 +231,18 @@
             }
             if (j - start > endd - j - 1) {
                 stkpnt++;
-                stack(1, stkpnt) = start;
-                stack(2, stkpnt) = j;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = start;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = j;
                 stkpnt++;
-                stack(1, stkpnt) = j + 1;
-                stack(2, stkpnt) = endd;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = j + 1;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = endd;
             } else {
                 stkpnt++;
-                stack(1, stkpnt) = j + 1;
-                stack(2, stkpnt) = endd;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = j + 1;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = endd;
                 stkpnt++;
-                stack(1, stkpnt) = start;
-                stack(2, stkpnt) = j;
+                stack[(1 - 1) + (stkpnt - 1) * stacklen] = start;
+                stack[(2 - 1) + (stkpnt - 1) * stacklen] = j;
             }
         }
     }
--- Rorg2l.cpp_	2021-04-06 11:01:56.656232602 +0900
+++ Rorg2l.cpp	2021-04-06 11:02:13.044231625 +0900
@@ -96,7 +96,7 @@
         //        Apply H(i) to A(1:m-k+i,1:n-k+i) from the left
         //
         a[((m - n + ii) - 1) + (ii - 1) * lda] = one;
-        Rlarf("Left", m - n + ii, ii - 1, &a[(ii - 1) * lda], 1, &tau[i - 1], a, lda, work);
+        Rlarf("Left", m - n + ii, ii - 1, &a[(ii - 1) * lda], 1, tau[i - 1], a, lda, work);
         Rscal(m - n + ii - 1, -tau[i - 1], &a[(ii - 1) * lda], 1);
         a[((m - n + ii) - 1) + (ii - 1) * lda] = one - tau[i - 1];
         //
--- Rorg2r.cpp_	2021-04-06 11:03:12.315004669 +0900
+++ Rorg2r.cpp	2021-04-06 11:03:20.143024991 +0900
@@ -95,7 +95,7 @@
         //
         if (i < n) {
             a[(i - 1) + (i - 1) * lda] = one;
-            Rlarf("Left", m - i + 1, n - i, &a[(i - 1) + (i - 1) * lda], 1, &tau[i - 1], &a[(i - 1) + ((i + 1) - 1) * lda], lda, work);
+            Rlarf("Left", m - i + 1, n - i, &a[(i - 1) + (i - 1) * lda], 1, tau[i - 1], &a[(i - 1) + ((i + 1) - 1) * lda], lda, work);
         }
         if (i < m) {
             Rscal(m - i, -tau[i - 1], &a[((i + 1) - 1) + (i - 1) * lda], 1);
--- Rorgql.cpp_	2021-04-06 11:07:31.225191333 +0900
+++ Rorgql.cpp	2021-04-06 11:07:44.406190547 +0900
@@ -105,7 +105,7 @@
         //
         //        Determine when to cross over from blocked to unblocked code.
         //
-        nx = max(0, iMlaenv(3, "Rorgql", " ", m, n, k, -1));
+        nx = max((INTEGER)0, iMlaenv(3, "Rorgql", " ", m, n, k, -1));
         if (nx < k) {
             //
             //           Determine if workspace is large enough for blocked code.
@@ -118,7 +118,7 @@
                 //              determine the minimum value of NB.
                 //
                 nb = lwork / ldwork;
-                nbmin = max(2, iMlaenv(2, "Rorgql", " ", m, n, k, -1));
+                nbmin = max((INTEGER)2, iMlaenv(2, "Rorgql", " ", m, n, k, -1));
             }
         }
     }
--- Rsteqr.cpp_org	2021-04-06 11:26:48.893245295 +0900
+++ Rsteqr.cpp	2021-04-06 11:29:22.173868889 +0900
@@ -248,12 +248,12 @@
         //
         if (m == l + 1) {
             if (icompz > 0) {
-                Rlaev2(d[l - 1], &e[l - 1], &d[(l + 1) - 1], rt1, rt2, c, s);
+                Rlaev2(d[l - 1], e[l - 1], d[(l + 1) - 1], rt1, rt2, c, s);
                 work[l - 1] = c;
                 work[(n - 1 + l) - 1] = s;
                 Rlasr("R", "V", "B", n, 2, &work[l - 1], &work[(n - 1 + l) - 1], &z[(l - 1) * ldz], ldz);
             } else {
-                Rlae2(d[l - 1], &e[l - 1], &d[(l + 1) - 1], rt1, rt2);
+                Rlae2(d[l - 1], e[l - 1], d[(l + 1) - 1], rt1, rt2);
             }
             d[l - 1] = rt1;
             d[(l + 1) - 1] = rt2;
@@ -360,12 +360,12 @@
         //
         if (m == l - 1) {
             if (icompz > 0) {
-                Rlaev2(d[(l - 1) - 1], &e[(l - 1) - 1], &d[l - 1], rt1, rt2, c, s);
+                Rlaev2(d[(l - 1) - 1], e[(l - 1) - 1], d[l - 1], rt1, rt2, c, s);
                 work[m - 1] = c;
                 work[(n - 1 + m) - 1] = s;
                 Rlasr("R", "V", "F", n, 2, &work[m - 1], &work[(n - 1 + m) - 1], &z[((l - 1) - 1) * ldz], ldz);
             } else {
-                Rlae2(d[(l - 1) - 1], &e[(l - 1) - 1], &d[l - 1], rt1, rt2);
+                Rlae2(d[(l - 1) - 1], e[(l - 1) - 1], d[l - 1], rt1, rt2);
             }
             d[(l - 1) - 1] = rt1;
             d[l - 1] = rt2;
--- Cungqr.cpp_org	2021-04-06 11:31:18.119617342 +0900
+++ Cungqr.cpp	2021-04-06 11:31:41.648868728 +0900
@@ -94,7 +94,7 @@
         //
         //        Determine when to cross over from blocked to unblocked code.
         //
-        nx = max(0, iMlaenv(3, "Cungqr", " ", m, n, k, -1));
+        nx = max((INTEGER)0, iMlaenv(3, "Cungqr", " ", m, n, k, -1));
         if (nx < k) {
             //
             //           Determine if workspace is large enough for blocked code.
@@ -107,7 +107,7 @@
                 //              determine the minimum value of NB.
                 //
                 nb = lwork / ldwork;
-                nbmin = max(2, iMlaenv(2, "Cungqr", " ", m, n, k, -1));
+                nbmin = max((INTEGER)2, iMlaenv(2, "Cungqr", " ", m, n, k, -1));
             }
         }
     }
--- Rsterf.cpp_org	2021-04-06 11:34:48.701307312 +0900
+++ Rsterf.cpp	2021-04-06 11:35:18.890264302 +0900
@@ -210,7 +210,7 @@
         //
         if (m == l + 1) {
             rte = sqrt(e[l - 1]);
-            Rlae2(d[l - 1], rte, &d[(l + 1) - 1], rt1, rt2);
+            Rlae2(d[l - 1], rte, d[(l + 1) - 1], rt1, rt2);
             d[l - 1] = rt1;
             d[(l + 1) - 1] = rt2;
             e[l - 1] = zero;
@@ -303,7 +303,7 @@
         //
         if (m == l - 1) {
             rte = sqrt(e[(l - 1) - 1]);
-            Rlae2(d[l - 1], rte, &d[(l - 1) - 1], rt1, rt2);
+            Rlae2(d[l - 1], rte, d[(l - 1) - 1], rt1, rt2);
             d[l - 1] = rt1;
             d[(l - 1) - 1] = rt2;
             e[(l - 1) - 1] = zero;
--- Rlatrd.cpp	2021-04-06 11:42:07.179825001 +0900
+++ Rlatrd.cpp_new	2021-04-06 11:41:47.137345407 +0900
@@ -84,7 +84,7 @@
                 //              Generate elementary reflector H(i) to annihilate
                 //              A(1:i-2,i)
                 //
-                Rlarfg(i - 1, &a[((i - 1) - 1) + (i - 1) * lda], &a[(i - 1) * lda], 1, &tau[(i - 1) - 1]);
+                Rlarfg(i - 1, a[((i - 1) - 1) + (i - 1) * lda], &a[(i - 1) * lda], 1, tau[(i - 1) - 1]);
                 e[(i - 1) - 1] = a[((i - 1) - 1) + (i - 1) * lda];
                 a[((i - 1) - 1) + (i - 1) * lda] = one;
                 //
@@ -97,7 +97,7 @@
                     Rgemv("Transpose", i - 1, n - i, one, &a[((i + 1) - 1) * lda], lda, &a[(i - 1) * lda], 1, zero, &w[((i + 1) - 1) + (iw - 1) * ldw], 1);
                     Rgemv("No transpose", i - 1, n - i, -one, &w[((iw + 1) - 1) * ldw], ldw, &w[((i + 1) - 1) + (iw - 1) * ldw], 1, one, &w[(iw - 1) * ldw], 1);
                 }
-                Rscal(i - 1, &tau[(i - 1) - 1], &w[(iw - 1) * ldw], 1);
+                Rscal(i - 1, tau[(i - 1) - 1], &w[(iw - 1) * ldw], 1);
                 alpha = -half * tau[(i - 1) - 1] * Rdot(i - 1, &w[(iw - 1) * ldw], 1, &a[(i - 1) * lda], 1);
                 Raxpy(i - 1, alpha, &a[(i - 1) * lda], 1, &w[(iw - 1) * ldw], 1);
             }
@@ -118,7 +118,7 @@
                 //              Generate elementary reflector H(i) to annihilate
                 //              A(i+2:n,i)
                 //
-                Rlarfg(n - i, &a[((i + 1) - 1) + (i - 1) * lda], &a[((min(i + 2) - 1) + (n)-1) * lda], 1, &tau[i - 1]);
+                Rlarfg(n - i, &a[((i + 1) - 1) + (i - 1) * lda], &a[(min(i + 2, n) - 1) + (i - 1) * lda], 1, &tau[i - 1]);
                 e[i - 1] = a[((i + 1) - 1) + (i - 1) * lda];
                 a[((i + 1) - 1) + (i - 1) * lda] = one;
                 //
@@ -129,7 +129,7 @@
                 Rgemv("No transpose", n - i, i - 1, -one, &a[((i + 1) - 1)], lda, &w[(i - 1) * ldw], 1, one, &w[((i + 1) - 1) + (i - 1) * ldw], 1);
                 Rgemv("Transpose", n - i, i - 1, one, &a[((i + 1) - 1)], lda, &a[((i + 1) - 1) + (i - 1) * lda], 1, zero, &w[(i - 1) * ldw], 1);
                 Rgemv("No transpose", n - i, i - 1, -one, &w[((i + 1) - 1)], ldw, &w[(i - 1) * ldw], 1, one, &w[((i + 1) - 1) + (i - 1) * ldw], 1);
-                Rscal(n - i, &tau[i - 1], &w[((i + 1) - 1) + (i - 1) * ldw], 1);
+                Rscal(n - i, tau[i - 1], &w[((i + 1) - 1) + (i - 1) * ldw], 1);
                 alpha = -half * tau[i - 1] * Rdot(n - i, &w[((i + 1) - 1) + (i - 1) * ldw], 1, &a[((i + 1) - 1) + (i - 1) * lda], 1);
                 Raxpy(n - i, alpha, &a[((i + 1) - 1) + (i - 1) * lda], 1, &w[((i + 1) - 1) + (i - 1) * ldw], 1);
             }
